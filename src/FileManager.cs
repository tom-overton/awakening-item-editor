// Copyright (c) 2018 Tom Overton

using System;
using System.IO;
using System.Linq;

using DSDecmp.Formats.Nitro;

namespace AwakeningItemTool
{
    public class FileManager
    {
        private string filename;

        public byte[] DecompressedBytes { get; set; }
        public bool IsCompressedInputFile { get; private set; }

        public FileManager(string filename)
        {
            this.filename = filename;
            byte[] inputBytes = File.ReadAllBytes(filename);
            string extension = Path.GetExtension(filename);
            if (extension == ".lz")
            {
                this.IsCompressedInputFile = true;

                // According to LZ11.cs, the first four bytes of a compressed file
                // are header bytes. Trying to decompress a file straight from the game
                // without removing these bytes first results in an error,
                // so at first, I thought to skip them.
                // 
                // However, this only seems to apply if what I believe to be
                // "Flag data" from the LZ11 definition is set to 0x11. If it is
                // set to 0x00, then the decompression will actually work without
                // stripping the header for some reason (and fail to work if the
                // header is stripped). Fates doesn't care which format you give it,
                // but it seems like the unmodified files use the 0x11 scheme, while
                // files generated by FEFNightmare use the 0x00 scheme.
                if (inputBytes[4] == 0x11)
                {
                    inputBytes = inputBytes.Skip(4).ToArray();
                }

                this.DecompressedBytes = DecompressData(inputBytes);
            }
            else
            {
                this.IsCompressedInputFile = false;
                this.DecompressedBytes = inputBytes;
            }
        }

        public void WriteToFile(byte[] decompressedData, string outputFilename = null)
        {
            byte[] outputBytes = decompressedData;
            if (IsCompressedInputFile)
            {
                byte[] compressedData = CompressData(decompressedData);

                // Write the compressed file header, because it doesn't seem like LZ11 writes
                // the header itself when you call CompressData. I may be wrong about the
                // implementation here, but it seems to follow this pattern.
                byte[] compressedDataWithHeader = new byte[compressedData.Length + 4];
                compressedDataWithHeader[0] = 0x13;
                Array.Copy(compressedData, 0, compressedDataWithHeader, 4, compressedData.Length);
                Array.Copy(compressedData, 1, compressedDataWithHeader, 1, 3);

                outputBytes = compressedDataWithHeader;
            }

            string outputPath = outputFilename ?? this.filename;
            File.WriteAllBytes(outputPath, outputBytes);
        }

        private byte[] CompressData(byte[] decompressedData)
        {
            MemoryStream decompressedStream = new MemoryStream(decompressedData);
            MemoryStream compressedStream = new MemoryStream();
            LZ11 compressor = new LZ11();
            compressor.Compress(decompressedStream, decompressedData.Length, compressedStream);
            return compressedStream.ToArray();
        }

        private byte[] DecompressData(byte[] compressedData)
        {
            MemoryStream compressedStream = new MemoryStream(compressedData);
            MemoryStream decompressedStream = new MemoryStream();
            LZ11 decompressor = new LZ11();
            decompressor.Decompress(compressedStream, compressedData.Length, decompressedStream);
            return decompressedStream.ToArray();
        }
    }
}
